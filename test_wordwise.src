module entry_point ( , ap_start, , ap_done, , ap_idle, , ap_ready, , speed, , time_r, , temptemp1, , temptemp1_ap_vld, , ap_return , ); , input ap_start; , output ap_done; , output ap_idle; , output ap_ready; , input [31:0] speed; , input [31:0] time_r; , output [31:0] temptemp1; , output temptemp1_ap_vld; , output [31:0] ap_return; , reg temptemp1_ap_vld; , wire [31:0] distance_fu_45_p2; , wire ap_ce_reg; , entry_point_mul_32s_32s_32_1_1 #( , .ID( 1 ), , .NUM_STAGE( 1 ), , .din0_WIDTH( 32 ), , .din1_WIDTH( 32 ), , .dout_WIDTH( 32 )) , mul_32s_32s_32_1_1_U1( , .din0(time_r), , .din1(speed), , .dout(distance_fu_45_p2) , ); , always @ (*) begin , if ((ap_start == 1'b1)) begin , temptemp1_ap_vld = 1'b1; , end else begin , temptemp1_ap_vld = 1'b0; , end , end , assign ap_done = ap_start; , assign ap_idle = 1'b1; , assign ap_ready = ap_start; , assign ap_return = 32'd0; , assign temptemp1 = distance_fu_45_p2; , endmodule , module entry_point_mul_32s_32s_32_1_1(din0, din1, dout); , parameter ID = 1; , parameter NUM_STAGE = 0; , parameter din0_WIDTH = 14; , parameter din1_WIDTH = 12; , parameter dout_WIDTH = 26; , input [din0_WIDTH - 1 : 0] din0; , input [din1_WIDTH - 1 : 0] din1; , output [dout_WIDTH - 1 : 0] dout; , assign dout = $signed(din0) * $signed(din1); , endmodule
module entry_point ( , ap_start, , ap_done, , ap_idle, , ap_ready, , a_i, , a_o, , a_o_ap_vld, , b_i, , b_o, , b_o_ap_vld, , temptemp1, , temptemp1_ap_vld, , temptemp2, , temptemp2_ap_vld, , ap_return , ); , input ap_start; , output ap_done; , output ap_idle; , output ap_ready; , input [31:0] a_i; , output [31:0] a_o; , output a_o_ap_vld; , input [31:0] b_i; , output [31:0] b_o; , output b_o_ap_vld; , output [31:0] temptemp1; , output temptemp1_ap_vld; , output [31:0] temptemp2; , output temptemp2_ap_vld; , output [31:0] ap_return; , reg a_o_ap_vld; , reg b_o_ap_vld; , reg temptemp1_ap_vld; , reg temptemp2_ap_vld; , wire ap_ce_reg; , always @ (*) begin , if ((ap_start == 1'b1)) begin , a_o_ap_vld = 1'b1; , end else begin , a_o_ap_vld = 1'b0; , end , end , always @ (*) begin , if ((ap_start == 1'b1)) begin , b_o_ap_vld = 1'b1; , end else begin , b_o_ap_vld = 1'b0; , end , end , always @ (*) begin , if ((ap_start == 1'b1)) begin , temptemp1_ap_vld = 1'b1; , end else begin , temptemp1_ap_vld = 1'b0; , end , end , always @ (*) begin , if ((ap_start == 1'b1)) begin , temptemp2_ap_vld = 1'b1; , end else begin , temptemp2_ap_vld = 1'b0; , end , end , assign a_o = b_i; , assign ap_done = ap_start; , assign ap_idle = 1'b1; , assign ap_ready = ap_start; , assign ap_return = 32'd0; , assign b_o = a_i; , assign temptemp1 = b_i; , assign temptemp2 = a_i; , endmodule
module entry_point ( , ap_clk, , ap_rst, , ap_start, , ap_done, , ap_idle, , ap_ready, , N, , arr, , temptemp1, , temptemp1_ap_vld, , temptemp2, , temptemp2_ap_vld, , ap_return , ); , parameter ap_ST_fsm_state1 = 1'd1; , input ap_clk; , input ap_rst; , input ap_start; , output ap_done; , output ap_idle; , output ap_ready; , input [31:0] N; , input [31:0] arr; , output [31:0] temptemp1; , output temptemp1_ap_vld; , output [31:0] temptemp2; , output temptemp2_ap_vld; , output [31:0] ap_return; , reg ap_idle; , reg temptemp1_ap_vld; , reg temptemp2_ap_vld; , (* fsm_encoding = "none" *) reg [0:0] ap_CS_fsm; , wire ap_CS_fsm_state1; , reg ap_block_state1_pp0_stage0_iter0; , wire [0:0] icmp_ln10_fu_106_p2; , reg ap_condition_exit_pp0_iter0_stage0; , wire ap_loop_exit_ready; , reg ap_ready_int; , reg [31:0] odd_fu_42; , wire [31:0] odd_2_fu_136_p3; , wire ap_loop_init; , reg [31:0] ap_sig_allocacmp_odd_load; , reg [31:0] ap_sig_allocacmp_odd_load_1; , reg [31:0] even_fu_46; , wire [31:0] even_2_fu_144_p3; , reg [31:0] ap_sig_allocacmp_even_load; , reg [31:0] ap_sig_allocacmp_even_load_1; , reg [30:0] i_fu_50; , wire [30:0] add_ln10_fu_112_p2; , reg [30:0] ap_sig_allocacmp_i_load; , wire [31:0] i_cast_fu_102_p1; , wire [0:0] trunc_ln12_fu_80_p1; , wire [31:0] odd_1_fu_130_p2; , wire [31:0] even_1_fu_124_p2; , reg ap_done_reg; , wire ap_continue_int; , reg ap_done_int; , reg [0:0] ap_NS_fsm; , reg ap_ST_fsm_state1_blk; , wire ap_start_int; , wire ap_ce_reg; , initial begin , #0 ap_CS_fsm = 1'd1; , #0 ap_done_reg = 1'b0; , end , entry_point_flow_control_loop_pipe flow_control_loop_pipe_U( , .ap_clk(ap_clk), , .ap_rst(ap_rst), , .ap_start(ap_start), , .ap_ready(ap_ready), , .ap_done(ap_done), , .ap_start_int(ap_start_int), , .ap_loop_init(ap_loop_init), , .ap_ready_int(ap_ready_int), , .ap_loop_exit_ready(ap_condition_exit_pp0_iter0_stage0), , .ap_loop_exit_done(ap_done_int), , .ap_continue_int(ap_continue_int), , .ap_done_int(ap_done_int), , .ap_continue(1'b1) , ); , always @ (posedge ap_clk) begin , if (ap_rst == 1'b1) begin , ap_CS_fsm <= ap_ST_fsm_state1; , end else begin , ap_CS_fsm <= ap_NS_fsm; , end , end , always @ (posedge ap_clk) begin , if (ap_rst == 1'b1) begin , ap_done_reg <= 1'b0; , end else begin , if ((ap_continue_int == 1'b1)) begin , ap_done_reg <= 1'b0; , end else if (((ap_loop_exit_ready == 1'b1) & (1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin , ap_done_reg <= 1'b1; , end , end , end , always @ (posedge ap_clk) begin , if (((1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin , if ((icmp_ln10_fu_106_p2 == 1'd1)) begin , even_fu_46 <= even_2_fu_144_p3; , end else if ((ap_loop_init == 1'b1)) begin , even_fu_46 <= 32'd0; , end , end , end , always @ (posedge ap_clk) begin , if (((1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin , if ((icmp_ln10_fu_106_p2 == 1'd1)) begin , i_fu_50 <= add_ln10_fu_112_p2; , end else if ((ap_loop_init == 1'b1)) begin , i_fu_50 <= 31'd0; , end , end , end , always @ (posedge ap_clk) begin , if (((1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin , if ((icmp_ln10_fu_106_p2 == 1'd1)) begin , odd_fu_42 <= odd_2_fu_136_p3; , end else if ((ap_loop_init == 1'b1)) begin , odd_fu_42 <= 32'd0; , end , end , end , always @ (*) begin , if ((ap_start_int == 1'b0)) begin , ap_ST_fsm_state1_blk = 1'b1; , end else begin , ap_ST_fsm_state1_blk = 1'b0; , end , end , always @ (*) begin , if (((icmp_ln10_fu_106_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin , ap_condition_exit_pp0_iter0_stage0 = 1'b1; , end else begin , ap_condition_exit_pp0_iter0_stage0 = 1'b0; , end , end , always @ (*) begin , if (((ap_loop_exit_ready == 1'b1) & (1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin , ap_done_int = 1'b1; , end else begin , ap_done_int = ap_done_reg; , end , end , always @ (*) begin , if (((1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b0))) begin , ap_idle = 1'b1; , end else begin , ap_idle = 1'b0; , end , end , always @ (*) begin , if (((1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin , ap_ready_int = 1'b1; , end else begin , ap_ready_int = 1'b0; , end , end , always @ (*) begin , if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin , ap_sig_allocacmp_even_load = 32'd0; , end else begin , ap_sig_allocacmp_even_load = even_fu_46; , end , end , always @ (*) begin , if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin , ap_sig_allocacmp_even_load_1 = 32'd0; , end else begin , ap_sig_allocacmp_even_load_1 = even_fu_46; , end , end , always @ (*) begin , if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin , ap_sig_allocacmp_i_load = 31'd0; , end else begin , ap_sig_allocacmp_i_load = i_fu_50; , end , end , always @ (*) begin , if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin , ap_sig_allocacmp_odd_load = 32'd0; , end else begin , ap_sig_allocacmp_odd_load = odd_fu_42; , end , end , always @ (*) begin , if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin , ap_sig_allocacmp_odd_load_1 = 32'd0; , end else begin , ap_sig_allocacmp_odd_load_1 = odd_fu_42; , end , end , always @ (*) begin , if (((icmp_ln10_fu_106_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin , temptemp1_ap_vld = 1'b1; , end else begin , temptemp1_ap_vld = 1'b0; , end , end , always @ (*) begin , if (((icmp_ln10_fu_106_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin , temptemp2_ap_vld = 1'b1; , end else begin , temptemp2_ap_vld = 1'b0; , end , end , always @ (*) begin , case (ap_CS_fsm) , ap_ST_fsm_state1 : begin , ap_NS_fsm = ap_ST_fsm_state1; , end , default : begin , ap_NS_fsm = 'bx; , end , endcase , end , assign add_ln10_fu_112_p2 = (ap_sig_allocacmp_i_load + 31'd1); , assign ap_CS_fsm_state1 = ap_CS_fsm[32'd0]; , always @ (*) begin , ap_block_state1_pp0_stage0_iter0 = (ap_start_int == 1'b0); , end , assign ap_loop_exit_ready = ap_condition_exit_pp0_iter0_stage0; , assign ap_return = 32'd0; , assign even_1_fu_124_p2 = (ap_sig_allocacmp_even_load + 32'd1); , assign even_2_fu_144_p3 = ((trunc_ln12_fu_80_p1[0:0] == 1'b1) ? ap_sig_allocacmp_even_load : even_1_fu_124_p2); , assign i_cast_fu_102_p1 = ap_sig_allocacmp_i_load; , assign icmp_ln10_fu_106_p2 = (($signed(i_cast_fu_102_p1) < $signed(N)) ? 1'b1 : 1'b0); , assign odd_1_fu_130_p2 = (ap_sig_allocacmp_odd_load + 32'd1); , assign odd_2_fu_136_p3 = ((trunc_ln12_fu_80_p1[0:0] == 1'b1) ? odd_1_fu_130_p2 : ap_sig_allocacmp_odd_load); , assign temptemp1 = ap_sig_allocacmp_even_load_1; , assign temptemp2 = ap_sig_allocacmp_odd_load_1; , assign trunc_ln12_fu_80_p1 = arr[0:0]; , endmodule , module entry_point_flow_control_loop_pipe( , ap_clk, , ap_rst, , ap_start, , ap_ready, , ap_done, , ap_continue, , ap_start_int, , ap_ready_int, , ap_done_int, , ap_continue_int, , ap_loop_init, , ap_loop_exit_ready, , ap_loop_exit_done , ); , input ap_clk; , input ap_rst; , input ap_start; , output ap_ready; , output ap_done; , input ap_continue; , output ap_start_int; , input ap_ready_int; , input ap_done_int; , output ap_continue_int; , output ap_loop_init; , reg ap_loop_init; , input ap_loop_exit_ready; , input ap_loop_exit_done; , initial begin , #0 ap_loop_init = 1'b1; , end , assign ap_start_int = ap_start; , assign ap_continue_int = ap_continue; , assign ap_done = ap_loop_exit_done; , assign ap_ready = ap_loop_exit_ready; , always @ (posedge ap_clk) , begin , if (ap_rst == 1'b1) begin , ap_loop_init <= 1'b1; , end else if(ap_loop_exit_ready == 1'b1) begin , ap_loop_init <= 1'b1; , end else if(ap_ready_int == 1'b1) begin , ap_loop_init <= 1'b0; , end , end , endmodule
module entry_point ( , ap_start, , ap_done, , ap_idle, , ap_ready, , temptemp1, , temptemp1_ap_vld, , temptemp2, , temptemp2_ap_vld, , temptemp3, , temptemp3_ap_vld, , temptemp4, , temptemp4_ap_vld, , ap_return , ); , input ap_start; , output ap_done; , output ap_idle; , output ap_ready; , output [31:0] temptemp1; , output temptemp1_ap_vld; , output [31:0] temptemp2; , output temptemp2_ap_vld; , output [31:0] temptemp3; , output temptemp3_ap_vld; , output [31:0] temptemp4; , output temptemp4_ap_vld; , output [31:0] ap_return; , reg temptemp1_ap_vld; , reg temptemp2_ap_vld; , reg temptemp3_ap_vld; , reg temptemp4_ap_vld; , wire ap_ce_reg; , always @ (*) begin , if ((ap_start == 1'b1)) begin , temptemp1_ap_vld = 1'b1; , end else begin , temptemp1_ap_vld = 1'b0; , end , end , always @ (*) begin , if ((ap_start == 1'b1)) begin , temptemp2_ap_vld = 1'b1; , end else begin , temptemp2_ap_vld = 1'b0; , end , end , always @ (*) begin , if ((ap_start == 1'b1)) begin , temptemp3_ap_vld = 1'b1; , end else begin , temptemp3_ap_vld = 1'b0; , end , end , always @ (*) begin , if ((ap_start == 1'b1)) begin , temptemp4_ap_vld = 1'b1; , end else begin , temptemp4_ap_vld = 1'b0; , end , end , assign ap_done = ap_start; , assign ap_idle = 1'b1; , assign ap_ready = ap_start; , assign ap_return = 32'd0; , assign temptemp1 = 32'd1; , assign temptemp2 = 32'd4; , assign temptemp3 = 32'd4; , assign temptemp4 = 32'd8; , endmodule
module entry_point ( , ap_clk, , ap_rst, , ap_start, , ap_done, , ap_idle, , ap_ready, , n, , temptemp1, , temptemp1_ap_vld, , ap_return , ); , parameter ap_ST_fsm_pp0_stage0 = 1'd1; , input ap_clk; , input ap_rst; , input ap_start; , output ap_done; , output ap_idle; , output ap_ready; , input [31:0] n; , output [31:0] temptemp1; , output temptemp1_ap_vld; , output [31:0] ap_return; , reg ap_idle; , reg temptemp1_ap_vld; , (* fsm_encoding = "none" *) reg [0:0] ap_CS_fsm; , wire ap_CS_fsm_pp0_stage0; , wire ap_enable_reg_pp0_iter0; , reg ap_enable_reg_pp0_iter1; , reg ap_idle_pp0; , wire ap_block_state1_pp0_stage0_iter0; , wire ap_block_state2_pp0_stage0_iter1; , wire ap_block_pp0_stage0_subdone; , wire [0:0] icmp_ln9_fu_97_p2; , reg ap_condition_exit_pp0_iter0_stage0; , wire ap_loop_exit_ready; , reg ap_ready_int; , wire ap_block_pp0_stage0_11001; , wire [6:0] arr_address0; , reg arr_ce0; , wire [31:0] arr_q0; , wire [63:0] i_cast1_fu_109_p1; , wire ap_block_pp0_stage0; , reg [31:0] sum_fu_42; , wire [31:0] sum_1_fu_122_p2; , reg [31:0] ap_sig_allocacmp_sum_load_1; , wire ap_loop_init; , reg [30:0] i_fu_46; , wire [30:0] add_ln9_fu_103_p2; , reg [30:0] ap_sig_allocacmp_i_1; , wire ap_block_pp0_stage0_01001; , wire [31:0] i_cast_fu_93_p1; , reg ap_done_reg; , wire ap_continue_int; , reg ap_done_int; , reg [0:0] ap_NS_fsm; , wire ap_enable_pp0; , wire ap_start_int; , reg ap_condition_85; , wire ap_ce_reg; , initial begin , #0 ap_CS_fsm = 1'd1; , #0 ap_enable_reg_pp0_iter1 = 1'b0; , #0 ap_done_reg = 1'b0; , end , entry_point_arr_RAM_AUTO_1R1W #( , .DataWidth( 32 ), , .AddressRange( 100 ), , .AddressWidth( 7 )) , arr_U( , .clk(ap_clk), , .reset(ap_rst), , .address0(arr_address0), , .ce0(arr_ce0), , .q0(arr_q0) , ); , entry_point_flow_control_loop_pipe flow_control_loop_pipe_U( , .ap_clk(ap_clk), , .ap_rst(ap_rst), , .ap_start(ap_start), , .ap_ready(ap_ready), , .ap_done(ap_done), , .ap_start_int(ap_start_int), , .ap_loop_init(ap_loop_init), , .ap_ready_int(ap_ready_int), , .ap_loop_exit_ready(ap_condition_exit_pp0_iter0_stage0), , .ap_loop_exit_done(ap_done_int), , .ap_continue_int(ap_continue_int), , .ap_done_int(ap_done_int), , .ap_continue(1'b1) , ); , always @ (posedge ap_clk) begin , if (ap_rst == 1'b1) begin , ap_CS_fsm <= ap_ST_fsm_pp0_stage0; , end else begin , ap_CS_fsm <= ap_NS_fsm; , end , end , always @ (posedge ap_clk) begin , if (ap_rst == 1'b1) begin , ap_done_reg <= 1'b0; , end else begin , if ((ap_continue_int == 1'b1)) begin , ap_done_reg <= 1'b0; , end else if (((ap_loop_exit_ready == 1'b1) & (1'b0 == ap_block_pp0_stage0_subdone) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin , ap_done_reg <= 1'b1; , end , end , end , always @ (posedge ap_clk) begin , if (ap_rst == 1'b1) begin , ap_enable_reg_pp0_iter1 <= 1'b0; , end else begin , if ((1'b1 == ap_condition_exit_pp0_iter0_stage0)) begin , ap_enable_reg_pp0_iter1 <= 1'b0; , end else if (((1'b0 == ap_block_pp0_stage0_subdone) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin , ap_enable_reg_pp0_iter1 <= ap_start_int; , end , end , end , always @ (posedge ap_clk) begin , if ((1'b1 == ap_condition_85)) begin , if ((icmp_ln9_fu_97_p2 == 1'd1)) begin , i_fu_46 <= add_ln9_fu_103_p2; , end else if ((ap_loop_init == 1'b1)) begin , i_fu_46 <= 31'd0; , end , end , end , always @ (posedge ap_clk) begin , if (((1'b0 == ap_block_pp0_stage0_11001) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin , if (((ap_loop_init == 1'b1) & (ap_enable_reg_pp0_iter0 == 1'b1))) begin , sum_fu_42 <= 32'd0; , end else if ((ap_enable_reg_pp0_iter1 == 1'b1)) begin , sum_fu_42 <= sum_1_fu_122_p2; , end , end , end , always @ (*) begin , if (((icmp_ln9_fu_97_p2 == 1'd0) & (1'b0 == ap_block_pp0_stage0_subdone) & (ap_enable_reg_pp0_iter0 == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin , ap_condition_exit_pp0_iter0_stage0 = 1'b1; , end else begin , ap_condition_exit_pp0_iter0_stage0 = 1'b0; , end , end , always @ (*) begin , if (((ap_loop_exit_ready == 1'b1) & (1'b0 == ap_block_pp0_stage0_subdone) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin , ap_done_int = 1'b1; , end else begin , ap_done_int = ap_done_reg; , end , end , always @ (*) begin , if (((ap_idle_pp0 == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0) & (ap_start_int == 1'b0))) begin , ap_idle = 1'b1; , end else begin , ap_idle = 1'b0; , end , end , always @ (*) begin , if (((ap_enable_reg_pp0_iter1 == 1'b0) & (ap_enable_reg_pp0_iter0 == 1'b0))) begin , ap_idle_pp0 = 1'b1; , end else begin , ap_idle_pp0 = 1'b0; , end , end , always @ (*) begin , if (((1'b0 == ap_block_pp0_stage0_subdone) & (ap_enable_reg_pp0_iter0 == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin , ap_ready_int = 1'b1; , end else begin , ap_ready_int = 1'b0; , end , end , always @ (*) begin , if (((ap_loop_init == 1'b1) & (1'b0 == ap_block_pp0_stage0) & (ap_enable_reg_pp0_iter0 == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin , ap_sig_allocacmp_i_1 = 31'd0; , end else begin , ap_sig_allocacmp_i_1 = i_fu_46; , end , end , always @ (*) begin , if (((1'b0 == ap_block_pp0_stage0) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin , if (((ap_loop_init == 1'b1) & (ap_enable_reg_pp0_iter0 == 1'b1))) begin , ap_sig_allocacmp_sum_load_1 = 32'd0; , end else if ((ap_enable_reg_pp0_iter1 == 1'b1)) begin , ap_sig_allocacmp_sum_load_1 = sum_1_fu_122_p2; , end else begin , ap_sig_allocacmp_sum_load_1 = sum_fu_42; , end , end else begin , ap_sig_allocacmp_sum_load_1 = sum_fu_42; , end , end , always @ (*) begin , if (((1'b0 == ap_block_pp0_stage0_11001) & (ap_enable_reg_pp0_iter0 == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin , arr_ce0 = 1'b1; , end else begin , arr_ce0 = 1'b0; , end , end , always @ (*) begin , if (((icmp_ln9_fu_97_p2 == 1'd0) & (1'b0 == ap_block_pp0_stage0_11001) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin , temptemp1_ap_vld = 1'b1; , end else begin , temptemp1_ap_vld = 1'b0; , end , end , always @ (*) begin , case (ap_CS_fsm) , ap_ST_fsm_pp0_stage0 : begin , ap_NS_fsm = ap_ST_fsm_pp0_stage0; , end , default : begin , ap_NS_fsm = 'bx; , end , endcase , end , assign add_ln9_fu_103_p2 = (ap_sig_allocacmp_i_1 + 31'd1); , assign ap_CS_fsm_pp0_stage0 = ap_CS_fsm[32'd0]; , assign ap_block_pp0_stage0 = ~(1'b1 == 1'b1); , assign ap_block_pp0_stage0_01001 = ~(1'b1 == 1'b1); , assign ap_block_pp0_stage0_11001 = ~(1'b1 == 1'b1); , assign ap_block_pp0_stage0_subdone = ~(1'b1 == 1'b1); , assign ap_block_state1_pp0_stage0_iter0 = ~(1'b1 == 1'b1); , assign ap_block_state2_pp0_stage0_iter1 = ~(1'b1 == 1'b1); , always @ (*) begin , ap_condition_85 = ((1'b0 == ap_block_pp0_stage0_11001) & (ap_enable_reg_pp0_iter0 == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0)); , end , assign ap_enable_pp0 = (ap_idle_pp0 ^ 1'b1); , assign ap_enable_reg_pp0_iter0 = ap_start_int; , assign ap_loop_exit_ready = ap_condition_exit_pp0_iter0_stage0; , assign ap_return = 32'd0; , assign arr_address0 = i_cast1_fu_109_p1; , assign i_cast1_fu_109_p1 = ap_sig_allocacmp_i_1; , assign i_cast_fu_93_p1 = ap_sig_allocacmp_i_1; , assign icmp_ln9_fu_97_p2 = (($signed(i_cast_fu_93_p1) < $signed(n)) ? 1'b1 : 1'b0); , assign sum_1_fu_122_p2 = (arr_q0 + sum_fu_42); , assign temptemp1 = ap_sig_allocacmp_sum_load_1; , endmodule , module entry_point_arr_RAM_AUTO_1R1W ( , address0, ce0, q0, , reset, clk); , parameter DataWidth = 32; , parameter AddressWidth = 7; , parameter AddressRange = 100; , input[AddressWidth-1:0] address0; , input ce0; , output reg[DataWidth-1:0] q0; , input reset; , input clk; , reg [DataWidth-1:0] rom0[0:AddressRange-1]; , initial begin , rom0[0]=8'h0; , rom0[1]=8'h0; , rom0[2]=8'h0; , rom0[3]=8'h0; , rom0[4]=8'h0; , rom0[5]=8'h0; , rom0[6]=8'h0; , rom0[7]=8'h0; , rom0[8]=8'h0; , rom0[9]=8'h0; , rom0[10]=8'h0; , rom0[11]=8'h0; , rom0[12]=8'h0; , rom0[13]=8'h0; , rom0[14]=8'h0; , rom0[15]=8'h0; , rom0[16]=8'h0; , rom0[17]=8'h0; , rom0[18]=8'h0; , rom0[19]=8'h0; , rom0[20]=8'h0; , rom0[21]=8'h0; , rom0[22]=8'h0; , rom0[23]=8'h0; , rom0[24]=8'h0; , rom0[25]=8'h0; , rom0[26]=8'h0; , rom0[27]=8'h0; , rom0[28]=8'h0; , rom0[29]=8'h0; , rom0[30]=8'h0; , rom0[31]=8'h0; , rom0[32]=8'h0; , rom0[33]=8'h0; , rom0[34]=8'h0; , rom0[35]=8'h0; , rom0[36]=8'h0; , rom0[37]=8'h0; , rom0[38]=8'h0; , rom0[39]=8'h0; , rom0[40]=8'h0; , rom0[41]=8'h0; , rom0[42]=8'h0; , rom0[43]=8'h0; , rom0[44]=8'h0; , rom0[45]=8'h0; , rom0[46]=8'h0; , rom0[47]=8'h0; , rom0[48]=8'h0; , rom0[49]=8'h0; , rom0[50]=8'h0; , rom0[51]=8'h0; , rom0[52]=8'h0; , rom0[53]=8'h0; , rom0[54]=8'h0; , rom0[55]=8'h0; , rom0[56]=8'h0; , rom0[57]=8'h0; , rom0[58]=8'h0; , rom0[59]=8'h0; , rom0[60]=8'h0; , rom0[61]=8'h0; , rom0[62]=8'h0; , rom0[63]=8'h0; , rom0[64]=8'h0; , rom0[65]=8'h0; , rom0[66]=8'h0; , rom0[67]=8'h0; , rom0[68]=8'h0; , rom0[69]=8'h0; , rom0[70]=8'h0; , rom0[71]=8'h0; , rom0[72]=8'h0; , rom0[73]=8'h0; , rom0[74]=8'h0; , rom0[75]=8'h0; , rom0[76]=8'h0; , rom0[77]=8'h0; , rom0[78]=8'h0; , rom0[79]=8'h0; , rom0[80]=8'h0; , rom0[81]=8'h0; , rom0[82]=8'h0; , rom0[83]=8'h0; , rom0[84]=8'h0; , rom0[85]=8'h0; , rom0[86]=8'h0; , rom0[87]=8'h0; , rom0[88]=8'h0; , rom0[89]=8'h0; , rom0[90]=8'h0; , rom0[91]=8'h0; , rom0[92]=8'h0; , rom0[93]=8'h0; , rom0[94]=8'h0; , rom0[95]=8'h0; , rom0[96]=8'h0; , rom0[97]=8'h0; , rom0[98]=8'h0; , rom0[99]=8'h0; , end , always @(posedge clk) , begin , if (ce0) , begin , q0 <= rom0[address0]; , end , end , endmodule , module entry_point_flow_control_loop_pipe( , ap_clk, , ap_rst, , ap_start, , ap_ready, , ap_done, , ap_continue, , ap_start_int, , ap_ready_int, , ap_done_int, , ap_continue_int, , ap_loop_init, , ap_loop_exit_ready, , ap_loop_exit_done , ); , input ap_clk; , input ap_rst; , input ap_start; , output ap_ready; , output ap_done; , input ap_continue; , output ap_start_int; , input ap_ready_int; , input ap_done_int; , output ap_continue_int; , output ap_loop_init; , reg ap_loop_init; , input ap_loop_exit_ready; , input ap_loop_exit_done; , initial begin , #0 ap_loop_init = 1'b1; , end , assign ap_start_int = ap_start; , assign ap_continue_int = ap_continue; , assign ap_done = ap_loop_exit_done; , assign ap_ready = ap_loop_exit_ready; , always @ (posedge ap_clk) , begin , if (ap_rst == 1'b1) begin , ap_loop_init <= 1'b1; , end else if(ap_loop_exit_ready == 1'b1) begin , ap_loop_init <= 1'b1; , end else if(ap_ready_int == 1'b1) begin , ap_loop_init <= 1'b0; , end , end , endmodule
