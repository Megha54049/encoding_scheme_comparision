S-0	module entry_point ( , ap_start, , ap_done, , ap_idle, , ap_ready, , speed, , time_r, , temptemp1, , temptemp1_ap_vld, , ap_return , ); , input ap_start; , output ap_done; , output ap_idle; , output ap_ready; , input [31:0] speed; , input [31:0] time_r; , output [31:0] temptemp1; , output temptemp1_ap_vld; , output [31:0] ap_return; , reg temptemp1_ap_vld; , wire [31:0] <unk> , wire ap_ce_reg; , entry_point_mul_32s_32s_32_1_1 #( , .ID( 1 ), , .NUM_STAGE( 1 ), , .din0_WIDTH( 32 ), , .din1_WIDTH( 32 ), , .dout_WIDTH( 32 )) , mul_32s_32s_32_1_1_U1( , <unk> , <unk> , <unk> , ); , always @ (*) begin , if ((ap_start == 1'b1)) begin , temptemp1_ap_vld = 1'b1; , end else begin , temptemp1_ap_vld = 1'b0; , end , end , assign ap_done = ap_start; , assign ap_idle = 1'b1; , assign ap_ready = ap_start; , assign ap_return = 32'd0; , assign temptemp1 = <unk> , endmodule , module entry_point_mul_32s_32s_32_1_1(din0, din1, dout); , parameter ID = 1; , parameter NUM_STAGE = 0; , parameter din0_WIDTH = 14; , parameter din1_WIDTH = 12; , parameter dout_WIDTH = 26; , input [din0_WIDTH - 1 : 0] din0; , input [din1_WIDTH - 1 : 0] din1; , output [dout_WIDTH - 1 : 0] dout; , assign dout = $signed(din0) * $signed(din1); , endmodule
T-0	#include <stdio.h> @ @ int entry_point ( int ( *speed ) , int ( *time ) , int ( *temptemp1 ) ) { @ int distance ; @ ; @ ; @ distance = ( *speed ) * ( *time ) ; @ { @ ( *temptemp1 ) = distance ; @ ; @ } @ return 0 ; @ }
H-0	-1.212087631225586	#include <stdio.h> @ @ int entry_point ( *temptemp1 ) , int ( *temptemp1 ) , int ( *temptemp1 ) ) , int ( *temptemp1 ) { @ int ( *temptemp1 ) { @ ; @ ; @ ; @ ; @ ( *temptemp1 ) = ( *temptemp1 ) ; @ ( *temptemp1 ) ; @ } @ } @ }
D-0	-1.212087631225586	#include <stdio.h> @ @ int entry_point ( *temptemp1 ) , int ( *temptemp1 ) , int ( *temptemp1 ) ) , int ( *temptemp1 ) { @ int ( *temptemp1 ) { @ ; @ ; @ ; @ ; @ ( *temptemp1 ) = ( *temptemp1 ) ; @ ( *temptemp1 ) ; @ } @ } @ }
P-0	-0.1235 -0.5165 -0.1274 -0.4675 -0.2814 -0.6569 -0.1846 -3.4337 -0.1123 -0.4008 -0.8007 -0.5209 -2.3717 -0.0861 -0.7209 -1.1796 -0.3435 -2.0183 -0.0920 -1.7800 -1.2700 -1.4233 -0.6153 -2.3623 -0.0937 -1.6928 -0.0691 -1.2875 -1.3545 -2.3556 -0.0991 -1.9423 -0.1102 -2.2454 -0.1370 -2.3119 -0.1671 -2.4948 -0.1820 -2.7417 -0.1864 -2.5462 -2.4168 -0.1252 -1.9476 -1.1199 -2.5614 -0.1218 -2.8438 -0.2179 -2.3579 -2.4555 -0.0978 -2.6622 -0.2030 -2.3271 -0.7695 -2.1955 -0.7420 -2.0663 -2.7998
S-3	module entry_point ( , ap_start, , ap_done, , ap_idle, , ap_ready, , temptemp1, , temptemp1_ap_vld, , temptemp2, , temptemp2_ap_vld, , temptemp3, , temptemp3_ap_vld, , temptemp4, , temptemp4_ap_vld, , ap_return , ); , input ap_start; , output ap_done; , output ap_idle; , output ap_ready; , output [31:0] temptemp1; , output temptemp1_ap_vld; , output [31:0] temptemp2; , output temptemp2_ap_vld; , output [31:0] temptemp3; , output temptemp3_ap_vld; , output [31:0] temptemp4; , output temptemp4_ap_vld; , output [31:0] ap_return; , reg temptemp1_ap_vld; , reg temptemp2_ap_vld; , reg temptemp3_ap_vld; , reg temptemp4_ap_vld; , wire ap_ce_reg; , always @ (*) begin , if ((ap_start == 1'b1)) begin , temptemp1_ap_vld = 1'b1; , end else begin , temptemp1_ap_vld = 1'b0; , end , end , always @ (*) begin , if ((ap_start == 1'b1)) begin , temptemp2_ap_vld = 1'b1; , end else begin , temptemp2_ap_vld = 1'b0; , end , end , always @ (*) begin , if ((ap_start == 1'b1)) begin , temptemp3_ap_vld = 1'b1; , end else begin , temptemp3_ap_vld = 1'b0; , end , end , always @ (*) begin , if ((ap_start == 1'b1)) begin , temptemp4_ap_vld = 1'b1; , end else begin , temptemp4_ap_vld = 1'b0; , end , end , assign ap_done = ap_start; , assign ap_idle = 1'b1; , assign ap_ready = ap_start; , assign ap_return = 32'd0; , assign temptemp1 = 32'd1; , assign temptemp2 = 32'd4; , assign temptemp3 = 32'd4; , assign temptemp4 = 32'd8; , endmodule
T-3	#include <stdio.h> @ @ int entry_point ( int ( *temptemp1 ) , int ( *temptemp2 ) , int ( *temptemp3 ) , int ( *temptemp4 ) ) { @ int size_char = sizeof ( char ) ; @ int size_int = sizeof ( int ) ; @ int size_float = sizeof ( float ) ; @ int size_long_int = sizeof ( long int ) ; @ { @ ( *temptemp1 ) = size_char ; @ ; @ } @ { @ ( *temptemp2 ) = size_int ; @ ; @ } @ { @ ( *temptemp3 ) = size_float ; @ ; @ } @ { @ ( *temptemp4 ) = size_long_int ; @ ; @ } @ return 0 ; @ }
H-3	-1.2034951448440552	#include <stdio.h> @ @ int entry_point ( int ( *temptemp1 ) , int ( *temptemp1 ) , int ( *temptemp1 ) , int ( *temptemp1 ) { @ int ( *temptemp1 ) { @ ; @ ; @ ; @ ; @ ( *temptemp1 ) = ( *temptemp1 ) = ( *temptemp1 ) ; @ }
D-3	-1.2034951448440552	#include <stdio.h> @ @ int entry_point ( int ( *temptemp1 ) , int ( *temptemp1 ) , int ( *temptemp1 ) , int ( *temptemp1 ) { @ int ( *temptemp1 ) { @ ; @ ; @ ; @ ; @ ( *temptemp1 ) = ( *temptemp1 ) = ( *temptemp1 ) ; @ }
P-3	-0.1292 -0.5093 -0.1525 -0.4665 -0.3247 -0.6037 -0.1879 -2.3225 -0.4701 -3.0583 -0.0824 -0.4452 -0.9241 -0.4676 -2.2117 -0.0751 -1.0722 -1.1105 -0.5369 -2.1778 -0.0914 -1.4183 -1.6105 -0.6256 -2.4818 -0.0908 -1.8811 -0.0797 -1.4786 -1.0491 -2.4465 -0.1012 -2.2395 -0.1293 -2.1600 -0.1645 -2.2832 -0.1951 -2.4703 -0.2032 -2.7473 -0.2213 -2.4168 -2.5577 -0.1284 -1.7994 -1.1110 -2.6908 -0.1220 -1.8607 -1.3433 -2.5788 -0.0986 -2.6567 -0.2265 -2.5545 -2.9577
S-1	module entry_point ( , ap_start, , ap_done, , ap_idle, , ap_ready, , a_i, , a_o, , a_o_ap_vld, , b_i, , b_o, , b_o_ap_vld, , temptemp1, , temptemp1_ap_vld, , temptemp2, , temptemp2_ap_vld, , ap_return , ); , input ap_start; , output ap_done; , output ap_idle; , output ap_ready; , input [31:0] a_i; , output [31:0] a_o; , output a_o_ap_vld; , input [31:0] b_i; , output [31:0] b_o; , output b_o_ap_vld; , output [31:0] temptemp1; , output temptemp1_ap_vld; , output [31:0] temptemp2; , output temptemp2_ap_vld; , output [31:0] ap_return; , reg a_o_ap_vld; , reg b_o_ap_vld; , reg temptemp1_ap_vld; , reg temptemp2_ap_vld; , wire ap_ce_reg; , always @ (*) begin , if ((ap_start == 1'b1)) begin , a_o_ap_vld = 1'b1; , end else begin , a_o_ap_vld = 1'b0; , end , end , always @ (*) begin , if ((ap_start == 1'b1)) begin , b_o_ap_vld = 1'b1; , end else begin , b_o_ap_vld = 1'b0; , end , end , always @ (*) begin , if ((ap_start == 1'b1)) begin , temptemp1_ap_vld = 1'b1; , end else begin , temptemp1_ap_vld = 1'b0; , end , end , always @ (*) begin , if ((ap_start == 1'b1)) begin , temptemp2_ap_vld = 1'b1; , end else begin , temptemp2_ap_vld = 1'b0; , end , end , assign a_o = b_i; , assign ap_done = ap_start; , assign ap_idle = 1'b1; , assign ap_ready = ap_start; , assign ap_return = 32'd0; , assign b_o = a_i; , assign temptemp1 = b_i; , assign temptemp2 = a_i; , endmodule
T-1	#include <stdio.h> @ @ int entry_point ( int ( *a ) , int ( *b ) , int ( *temptemp1 ) , int ( *temptemp2 ) ) { @ ; @ ; @ ( *a ) = ( *a ) + ( *b ) ; @ ( *b ) = ( *a ) - ( *b ) ; @ ( *a ) = ( *a ) - ( *b ) ; @ { @ ( *temptemp1 ) = ( *a ) ; @ ( *temptemp2 ) = ( *b ) ; @ ; @ } @ return 0 ; @ }
H-1	-1.193414568901062	#include <stdio.h> @ @ int entry_point ( int ( *temptemp1 ) , int ( *temptemp1 ) , int ( *temptemp1 ) , int ( *temptemp1 ) { @ int ( *temptemp1 ) { @ ; @ ; @ ; @ ; @ ( *temptemp1 ) = ( *temptemp1 ) = ( *temptemp1 ) ; @ }
D-1	-1.193414568901062	#include <stdio.h> @ @ int entry_point ( int ( *temptemp1 ) , int ( *temptemp1 ) , int ( *temptemp1 ) , int ( *temptemp1 ) { @ int ( *temptemp1 ) { @ ; @ ; @ ; @ ; @ ( *temptemp1 ) = ( *temptemp1 ) = ( *temptemp1 ) ; @ }
P-1	-0.1295 -0.5078 -0.1428 -0.4476 -0.3258 -0.6037 -0.1831 -2.3498 -0.4454 -2.9875 -0.0769 -0.4527 -0.9394 -0.4422 -2.1440 -0.0705 -1.1048 -1.1318 -0.5152 -2.1104 -0.0854 -1.4522 -1.6357 -0.6034 -2.4105 -0.0847 -1.8734 -0.0788 -1.4768 -1.0165 -2.3764 -0.0945 -2.2380 -0.1282 -2.1840 -0.1605 -2.3125 -0.1912 -2.5029 -0.1991 -2.7906 -0.2167 -2.3808 -2.4912 -0.1204 -1.7863 -1.0976 -2.6249 -0.1138 -1.8459 -1.3290 -2.5155 -0.0921 -2.7077 -0.2223 -2.5439 -2.9303
S-2	module entry_point ( , ap_clk, , ap_rst, , ap_start, , ap_done, , ap_idle, , ap_ready, , N, , arr, , temptemp1, , temptemp1_ap_vld, , temptemp2, , temptemp2_ap_vld, , ap_return , ); , parameter ap_ST_fsm_state1 = 1'd1; , input ap_clk; , input ap_rst; , input ap_start; , output ap_done; , output ap_idle; , output ap_ready; , input [31:0] N; , input [31:0] arr; , output [31:0] temptemp1; , output temptemp1_ap_vld; , output [31:0] temptemp2; , output temptemp2_ap_vld; , output [31:0] ap_return; , reg ap_idle; , reg temptemp1_ap_vld; , reg temptemp2_ap_vld; , (* fsm_encoding = "none" *) reg [0:0] ap_CS_fsm; , wire ap_CS_fsm_state1; , reg ap_block_state1_pp0_stage0_iter0; , wire [0:0] icmp_ln10_fu_106_p2; , reg ap_condition_exit_pp0_iter0_stage0; , wire ap_loop_exit_ready; , reg ap_ready_int; , reg [31:0] <unk> , wire [31:0] <unk> , wire ap_loop_init; , reg [31:0] <unk> , reg [31:0] <unk> , reg [31:0] <unk> , wire [31:0] <unk> , reg [31:0] <unk> , reg [31:0] <unk> , reg [30:0] i_fu_50; , wire [30:0] add_ln10_fu_112_p2; , reg [30:0] ap_sig_allocacmp_i_load; , wire [31:0] <unk> , wire [0:0] <unk> , wire [31:0] <unk> , wire [31:0] <unk> , reg ap_done_reg; , wire ap_continue_int; , reg ap_done_int; , reg [0:0] ap_NS_fsm; , reg ap_ST_fsm_state1_blk; , wire ap_start_int; , wire ap_ce_reg; , initial begin , #0 ap_CS_fsm = 1'd1; , #0 ap_done_reg = 1'b0; , end , entry_point_flow_control_loop_pipe flow_control_loop_pipe_U( , .ap_clk(ap_clk), , .ap_rst(ap_rst), , .ap_start(ap_start), , .ap_ready(ap_ready), , .ap_done(ap_done), , .ap_start_int(ap_start_int), , .ap_loop_init(ap_loop_init), , .ap_ready_int(ap_ready_int), , .ap_loop_exit_ready(ap_condition_exit_pp0_iter0_stage0), , .ap_loop_exit_done(ap_done_int), , .ap_continue_int(ap_continue_int), , .ap_done_int(ap_done_int), , .ap_continue(1'b1) , ); , always @ (posedge ap_clk) begin , if (ap_rst == 1'b1) begin , ap_CS_fsm <= ap_ST_fsm_state1; , end else begin , ap_CS_fsm <= ap_NS_fsm; , end , end , always @ (posedge ap_clk) begin , if (ap_rst == 1'b1) begin , ap_done_reg <= 1'b0; , end else begin , if ((ap_continue_int == 1'b1)) begin , ap_done_reg <= 1'b0; , end else if (((ap_loop_exit_ready == 1'b1) & (1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin , ap_done_reg <= 1'b1; , end , end , end , always @ (posedge ap_clk) begin , if (((1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin , if ((icmp_ln10_fu_106_p2 == 1'd1)) begin , <unk> <= <unk> , end else if ((ap_loop_init == 1'b1)) begin , <unk> <= 32'd0; , end , end , end , always @ (posedge ap_clk) begin , if (((1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin , if ((icmp_ln10_fu_106_p2 == 1'd1)) begin , i_fu_50 <= add_ln10_fu_112_p2; , end else if ((ap_loop_init == 1'b1)) begin , i_fu_50 <= 31'd0; , end , end , end , always @ (posedge ap_clk) begin , if (((1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin , if ((icmp_ln10_fu_106_p2 == 1'd1)) begin , <unk> <= <unk> , end else if ((ap_loop_init == 1'b1)) begin , <unk> <= 32'd0; , end , end , end , always @ (*) begin , if ((ap_start_int == 1'b0)) begin , ap_ST_fsm_state1_blk = 1'b1; , end else begin , ap_ST_fsm_state1_blk = 1'b0; , end , end , always @ (*) begin , if (((icmp_ln10_fu_106_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin , ap_condition_exit_pp0_iter0_stage0 = 1'b1; , end else begin , ap_condition_exit_pp0_iter0_stage0 = 1'b0; , end , end , always @ (*) begin , if (((ap_loop_exit_ready == 1'b1) & (1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin , ap_done_int = 1'b1; , end else begin , ap_done_int = ap_done_reg; , end , end , always @ (*) begin , if (((1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b0))) begin , ap_idle = 1'b1; , end else begin , ap_idle = 1'b0; , end , end , always @ (*) begin , if (((1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin , ap_ready_int = 1'b1; , end else begin , ap_ready_int = 1'b0; , end , end , always @ (*) begin , if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin , <unk> = 32'd0; , end else begin , <unk> = <unk> , end , end , always @ (*) begin , if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin , <unk> = 32'd0; , end else begin , <unk> = <unk> , end , end , always @ (*) begin , if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin , ap_sig_allocacmp_i_load = 31'd0; , end else begin , ap_sig_allocacmp_i_load = i_fu_50; , end , end , always @ (*) begin , if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin , <unk> = 32'd0; , end else begin , <unk> = <unk> , end , end , always @ (*) begin , if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin , <unk> = 32'd0; , end else begin , <unk> = <unk> , end , end , always @ (*) begin , if (((icmp_ln10_fu_106_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin , temptemp1_ap_vld = 1'b1; , end else begin , temptemp1_ap_vld = 1'b0; , end , end , always @ (*) begin , if (((icmp_ln10_fu_106_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin , temptemp2_ap_vld = 1'b1; , end else begin , temptemp2_ap_vld = 1'b0; , end , end , always @ (*) begin , case (ap_CS_fsm) , ap_ST_fsm_state1 : begin , ap_NS_fsm = ap_ST_fsm_state1; , end , default : begin , ap_NS_fsm = 'bx; , end , endcase , end , assign add_ln10_fu_112_p2 = (ap_sig_allocacmp_i_load + 31'd1); , assign ap_CS_fsm_state1 = ap_CS_fsm[32'd0]; , always @ (*) begin , ap_block_state1_pp0_stage0_iter0 = (ap_start_int == 1'b0); , end , assign ap_loop_exit_ready = ap_condition_exit_pp0_iter0_stage0; , assign ap_return = 32'd0; , assign <unk> = <unk> + 32'd1); , assign <unk> = <unk> == 1'b1) ? <unk> : <unk> , assign <unk> = ap_sig_allocacmp_i_load; , assign icmp_ln10_fu_106_p2 = <unk> < $signed(N)) ? 1'b1 : 1'b0); , assign <unk> = <unk> + 32'd1); , assign <unk> = <unk> == 1'b1) ? <unk> : <unk> , assign temptemp1 = <unk> , assign temptemp2 = <unk> , assign <unk> = arr[0:0]; , endmodule , module entry_point_flow_control_loop_pipe( , ap_clk, , ap_rst, , ap_start, , ap_ready, , ap_done, , ap_continue, , ap_start_int, , ap_ready_int, , ap_done_int, , ap_continue_int, , ap_loop_init, , ap_loop_exit_ready, , ap_loop_exit_done , ); , input ap_clk; , input ap_rst; , input ap_start; , output ap_ready; , output ap_done; , input ap_continue; , output ap_start_int; , input ap_ready_int; , input ap_done_int; , output ap_continue_int; , output ap_loop_init; , reg ap_loop_init; , input ap_loop_exit_ready; , input ap_loop_exit_done; , initial begin , #0 ap_loop_init = 1'b1; , end , assign ap_start_int = ap_start; , assign ap_continue_int = ap_continue; , assign ap_done = ap_loop_exit_done; , assign ap_ready = ap_loop_exit_ready; , always @ (posedge ap_clk) , begin , if (ap_rst == 1'b1) begin , ap_loop_init <= 1'b1; , end else if(ap_loop_exit_ready == 1'b1) begin , ap_loop_init <= 1'b1; , end else if(ap_ready_int == 1'b1) begin , ap_loop_init <= 1'b0; , end , end , endmodule
T-2	#include <stdio.h> @ @ int entry_point ( int ( *N ) , int ( *arr ) , int ( *temptemp1 ) , int ( *temptemp2 ) ) @ { @ int odd ; @ int even ; @ int i ; @ even = 0 ; @ odd = 0 ; @ for ( i = 0 ; i < ( *N ) ; i++ ) @ { @ if ( arr [ i ] % 2 == 0 ) @ { @ even = even + 1 ; @ } @ else @ { @ odd = odd + 1 ; @ } @ } @ { @ ( *temptemp1 ) = even ; @ ; @ } @ { @ ( *temptemp2 ) = odd ; @ ; @ } @ return 0 ; @ }
H-2	-1.1096396446228027	#include <stdio.h> @ @ int entry_point ( *temptemp1 ) , float ( *temptemp1 ) , float ( *temptemp1 ) , float ( *temptemp1 ) { @ ; @ ; @ ; @ ; @ ; @ ; @ ( *temptemp1 ) = ( *temptemp1 ) = ( *temptemp1 ) ; @ }
D-2	-1.1096396446228027	#include <stdio.h> @ @ int entry_point ( *temptemp1 ) , float ( *temptemp1 ) , float ( *temptemp1 ) , float ( *temptemp1 ) { @ ; @ ; @ ; @ ; @ ; @ ; @ ( *temptemp1 ) = ( *temptemp1 ) = ( *temptemp1 ) ; @ }
P-2	-0.1338 -0.4212 -0.1421 -0.2800 -0.7004 -0.3818 -0.1843 -3.3328 -0.0971 -0.4464 -1.0609 -0.2043 -2.1851 -0.0730 -0.8108 -1.3695 -0.1887 -1.8250 -0.0780 -1.4059 -1.2748 -0.4507 -2.0796 -0.0716 -1.7286 -0.0618 -2.1175 -0.0806 -1.9527 -0.1074 -2.0622 -0.1478 -2.2964 -0.1745 -2.4648 -0.1933 -2.6401 -0.2118 -2.7313 -2.1647 -0.1062 -1.8829 -1.2312 -2.2477 -0.1101 -1.6570 -1.2039 -2.3551 -0.1042 -2.6718 -0.2053 -2.3082 -2.3939
S-4	module entry_point ( , ap_clk, , ap_rst, , ap_start, , ap_done, , ap_idle, , ap_ready, , n, , temptemp1, , temptemp1_ap_vld, , ap_return , ); , parameter ap_ST_fsm_pp0_stage0 = 1'd1; , input ap_clk; , input ap_rst; , input ap_start; , output ap_done; , output ap_idle; , output ap_ready; , input [31:0] n; , output [31:0] temptemp1; , output temptemp1_ap_vld; , output [31:0] ap_return; , reg ap_idle; , reg temptemp1_ap_vld; , (* fsm_encoding = "none" *) reg [0:0] ap_CS_fsm; , wire ap_CS_fsm_pp0_stage0; , wire ap_enable_reg_pp0_iter0; , reg ap_enable_reg_pp0_iter1; , reg ap_idle_pp0; , wire ap_block_state1_pp0_stage0_iter0; , wire ap_block_state2_pp0_stage0_iter1; , wire ap_block_pp0_stage0_subdone; , wire [0:0] icmp_ln9_fu_97_p2; , reg ap_condition_exit_pp0_iter0_stage0; , wire ap_loop_exit_ready; , reg ap_ready_int; , wire ap_block_pp0_stage0_11001; , wire [6:0] arr_address0; , reg arr_ce0; , wire [31:0] arr_q0; , wire [63:0] <unk> , wire ap_block_pp0_stage0; , reg [31:0] sum_fu_42; , wire [31:0] <unk> , reg [31:0] ap_sig_allocacmp_sum_load_1; , wire ap_loop_init; , reg [30:0] i_fu_46; , wire [30:0] add_ln9_fu_103_p2; , reg [30:0] ap_sig_allocacmp_i_1; , wire ap_block_pp0_stage0_01001; , wire [31:0] <unk> , reg ap_done_reg; , wire ap_continue_int; , reg ap_done_int; , reg [0:0] ap_NS_fsm; , wire ap_enable_pp0; , wire ap_start_int; , reg <unk> , wire ap_ce_reg; , initial begin , #0 ap_CS_fsm = 1'd1; , #0 ap_enable_reg_pp0_iter1 = 1'b0; , #0 ap_done_reg = 1'b0; , end , entry_point_arr_RAM_AUTO_1R1W #( , .DataWidth( 32 ), , .AddressRange( 100 ), , .AddressWidth( 7 )) , arr_U( , .clk(ap_clk), , .reset(ap_rst), , .address0(arr_address0), , .ce0(arr_ce0), , .q0(arr_q0) , ); , entry_point_flow_control_loop_pipe flow_control_loop_pipe_U( , .ap_clk(ap_clk), , .ap_rst(ap_rst), , .ap_start(ap_start), , .ap_ready(ap_ready), , .ap_done(ap_done), , .ap_start_int(ap_start_int), , .ap_loop_init(ap_loop_init), , .ap_ready_int(ap_ready_int), , .ap_loop_exit_ready(ap_condition_exit_pp0_iter0_stage0), , .ap_loop_exit_done(ap_done_int), , .ap_continue_int(ap_continue_int), , .ap_done_int(ap_done_int), , .ap_continue(1'b1) , ); , always @ (posedge ap_clk) begin , if (ap_rst == 1'b1) begin , ap_CS_fsm <= ap_ST_fsm_pp0_stage0; , end else begin , ap_CS_fsm <= ap_NS_fsm; , end , end , always @ (posedge ap_clk) begin , if (ap_rst == 1'b1) begin , ap_done_reg <= 1'b0; , end else begin , if ((ap_continue_int == 1'b1)) begin , ap_done_reg <= 1'b0; , end else if (((ap_loop_exit_ready == 1'b1) & (1'b0 == ap_block_pp0_stage0_subdone) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin , ap_done_reg <= 1'b1; , end , end , end , always @ (posedge ap_clk) begin , if (ap_rst == 1'b1) begin , ap_enable_reg_pp0_iter1 <= 1'b0; , end else begin , if ((1'b1 == ap_condition_exit_pp0_iter0_stage0)) begin , ap_enable_reg_pp0_iter1 <= 1'b0; , end else if (((1'b0 == ap_block_pp0_stage0_subdone) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin , ap_enable_reg_pp0_iter1 <= ap_start_int; , end , end , end , always @ (posedge ap_clk) begin , if ((1'b1 == <unk> begin , if <unk> == 1'd1)) begin , i_fu_46 <= add_ln9_fu_103_p2; , end else if ((ap_loop_init == 1'b1)) begin , i_fu_46 <= 31'd0; , end , end , end , always @ (posedge ap_clk) begin , if (((1'b0 == ap_block_pp0_stage0_11001) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin , if (((ap_loop_init == 1'b1) & (ap_enable_reg_pp0_iter0 == 1'b1))) begin , sum_fu_42 <= 32'd0; , end else if ((ap_enable_reg_pp0_iter1 == 1'b1)) begin , sum_fu_42 <= <unk> , end , end , end , always @ (*) begin , if (((icmp_ln9_fu_97_p2 == 1'd0) & (1'b0 == ap_block_pp0_stage0_subdone) & (ap_enable_reg_pp0_iter0 == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin , ap_condition_exit_pp0_iter0_stage0 = 1'b1; , end else begin , ap_condition_exit_pp0_iter0_stage0 = 1'b0; , end , end , always @ (*) begin , if (((ap_loop_exit_ready == 1'b1) & (1'b0 == ap_block_pp0_stage0_subdone) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin , ap_done_int = 1'b1; , end else begin , ap_done_int = ap_done_reg; , end , end , always @ (*) begin , if (((ap_idle_pp0 == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0) & (ap_start_int == 1'b0))) begin , ap_idle = 1'b1; , end else begin , ap_idle = 1'b0; , end , end , always @ (*) begin , if (((ap_enable_reg_pp0_iter1 == 1'b0) & (ap_enable_reg_pp0_iter0 == 1'b0))) begin , ap_idle_pp0 = 1'b1; , end else begin , ap_idle_pp0 = 1'b0; , end , end , always @ (*) begin , if (((1'b0 == ap_block_pp0_stage0_subdone) & (ap_enable_reg_pp0_iter0 == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin , ap_ready_int = 1'b1; , end else begin , ap_ready_int = 1'b0; , end , end , always @ (*) begin , if (((ap_loop_init == 1'b1) & (1'b0 == ap_block_pp0_stage0) & (ap_enable_reg_pp0_iter0 == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin , ap_sig_allocacmp_i_1 = 31'd0; , end else begin , ap_sig_allocacmp_i_1 = i_fu_46; , end , end , always @ (*) begin , if (((1'b0 == ap_block_pp0_stage0) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin , if (((ap_loop_init == 1'b1) & (ap_enable_reg_pp0_iter0 == 1'b1))) begin , ap_sig_allocacmp_sum_load_1 = 32'd0; , end else if ((ap_enable_reg_pp0_iter1 == 1'b1)) begin , ap_sig_allocacmp_sum_load_1 = <unk> , end else begin , ap_sig_allocacmp_sum_load_1 = sum_fu_42; , end , end else begin , ap_sig_allocacmp_sum_load_1 = sum_fu_42; , end , end , always @ (*) begin , if (((1'b0 == ap_block_pp0_stage0_11001) & (ap_enable_reg_pp0_iter0 == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin , arr_ce0 = 1'b1; , end else begin , arr_ce0 = 1'b0; , end , end , always @ (*) begin , if (((icmp_ln9_fu_97_p2 == 1'd0) & (1'b0 == ap_block_pp0_stage0_11001) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin , temptemp1_ap_vld = 1'b1; , end else begin , temptemp1_ap_vld = 1'b0; , end , end , always @ (*) begin , case (ap_CS_fsm) , ap_ST_fsm_pp0_stage0 : begin , ap_NS_fsm = ap_ST_fsm_pp0_stage0; , end , default : begin , ap_NS_fsm = 'bx; , end , endcase , end , assign add_ln9_fu_103_p2 = (ap_sig_allocacmp_i_1 + 31'd1); , assign ap_CS_fsm_pp0_stage0 = ap_CS_fsm[32'd0]; , assign ap_block_pp0_stage0 = ~(1'b1 == 1'b1); , assign ap_block_pp0_stage0_01001 = ~(1'b1 == 1'b1); , assign ap_block_pp0_stage0_11001 = ~(1'b1 == 1'b1); , assign ap_block_pp0_stage0_subdone = ~(1'b1 == 1'b1); , assign ap_block_state1_pp0_stage0_iter0 = ~(1'b1 == 1'b1); , assign ap_block_state2_pp0_stage0_iter1 = ~(1'b1 == 1'b1); , always @ (*) begin , <unk> = ((1'b0 == ap_block_pp0_stage0_11001) & (ap_enable_reg_pp0_iter0 == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0)); , end , assign ap_enable_pp0 = (ap_idle_pp0 ^ 1'b1); , assign ap_enable_reg_pp0_iter0 = ap_start_int; , assign ap_loop_exit_ready = ap_condition_exit_pp0_iter0_stage0; , assign ap_return = 32'd0; , assign arr_address0 = <unk> , assign <unk> = ap_sig_allocacmp_i_1; , assign <unk> = ap_sig_allocacmp_i_1; , assign icmp_ln9_fu_97_p2 = <unk> < $signed(n)) ? 1'b1 : 1'b0); , assign <unk> = <unk> + <unk> , assign temptemp1 = ap_sig_allocacmp_sum_load_1; , endmodule , module entry_point_arr_RAM_AUTO_1R1W ( , address0, ce0, q0, , reset, clk); , parameter DataWidth = 32; , parameter AddressWidth = 7; , parameter AddressRange = 100; , input[AddressWidth-1:0] address0; , input ce0; , output reg[DataWidth-1:0] q0; , input reset; , input clk; , reg [DataWidth-1:0] rom0[0:AddressRange-1]; , initial begin , rom0[0]=8'h0; , rom0[1]=8'h0; , rom0[2]=8'h0; , rom0[3]=8'h0; , rom0[4]=8'h0; , rom0[5]=8'h0; , rom0[6]=8'h0; , rom0[7]=8'h0; , rom0[8]=8'h0; , rom0[9]=8'h0; , rom0[10]=8'h0; , rom0[11]=8'h0; , rom0[12]=8'h0; , rom0[13]=8'h0; , rom0[14]=8'h0; , rom0[15]=8'h0; , rom0[16]=8'h0; , rom0[17]=8'h0; , rom0[18]=8'h0; , rom0[19]=8'h0; , rom0[20]=8'h0; , rom0[21]=8'h0; , rom0[22]=8'h0; , rom0[23]=8'h0; , rom0[24]=8'h0; , rom0[25]=8'h0; , rom0[26]=8'h0; , rom0[27]=8'h0; , rom0[28]=8'h0; , rom0[29]=8'h0; , rom0[30]=8'h0; , rom0[31]=8'h0; , rom0[32]=8'h0; , rom0[33]=8'h0; , rom0[34]=8'h0; , rom0[35]=8'h0; , rom0[36]=8'h0; , rom0[37]=8'h0; , rom0[38]=8'h0; , rom0[39]=8'h0; , rom0[40]=8'h0; , rom0[41]=8'h0; , rom0[42]=8'h0; , rom0[43]=8'h0; , rom0[44]=8'h0; , rom0[45]=8'h0; , rom0[46]=8'h0; , rom0[47]=8'h0; , rom0[48]=8'h0; , rom0[49]=8'h0; , rom0[50]=8'h0; , rom0[51]=8'h0; , rom0[52]=8'h0; , rom0[53]=8'h0; , rom0[54]=8'h0; , rom0[55]=8'h0; , rom0[56]=8'h0; , rom0[57]=8'h0; , rom0[58]=8'h0; , rom0[59]=8'h0; , rom0[60]=8'h0; , rom0[61]=8'h0; , rom0[62]=8'h0; , rom0[63]=8'h0; , rom0[64]=8'h0; , rom0[65]=8'h0; , rom0[66]=8'h0; , rom0[67]=8'h0; , rom0[68]=8'h0; , rom0[69]=8'h0; , rom0[70]=8'h0; , rom0[71]=8'h0; , rom0[72]=8'h0; , rom0[73]=8'h0; , rom0[74]=8'h0; , rom0[75]=8'h0; , rom0[76]=8'h0; , rom0[77]=8'h0; , rom0[78]=8'h0; , rom0[79]=8'h0; , rom0[80]=8'h0; , rom0[81]=8'h0; , rom0[82]=8'h0; , rom0[83]=8'h0; , rom0[84]=8'h0; , rom0[85]=8'h0; , rom0[86]=8'h0; , rom0[87]=8'h0; , rom0[88]=8'h0; , rom0[89]=8'h0; , rom0[90]=8'h0; , rom0[91]=8'h0; , rom0[92]=8'h0; , rom0[93]=8'h0; , rom0[94]=8'h0; , rom0[95]=8'h0; , rom0[96]=8'h0; , rom0[97]=8'h0; , rom0[98]=8'h0; , rom0[99]=8'h0; , end , always @(posedge clk) , begin , if (ce0) , begin , q0 <= rom0[address0]; , end , end , endmodule , module entry_point_flow_control_loop_pipe( , ap_clk, , ap_rst, , ap_start, , ap_ready, , ap_done, , ap_continue, , ap_start_int, , ap_ready_int, , ap_done_int, , ap_continue_int, , ap_loop_init, , ap_loop_exit_ready, , ap_loop_exit_done , ); , input ap_clk; , input ap_rst; , input ap_start; , output ap_ready; , output ap_done; , input ap_continue; , output ap_start_int; , input ap_ready_int; , input ap_done_int; , output ap_continue_int; , output ap_loop_init; , reg ap_loop_init; , input ap_loop_exit_ready; , input ap_loop_exit_done; , initial begin , #0 ap_loop_init = 1'b1; , end , assign ap_start_int = ap_start; , assign ap_continue_int = ap_continue; , assign ap_done = ap_loop_exit_done; , assign ap_ready = ap_loop_exit_ready; , always @ (posedge ap_clk) , begin , if (ap_rst == 1'b1) begin , ap_loop_init <= 1'b1; , end else if(ap_loop_exit_ready == 1'b1) begin , ap_loop_init <= 1'b1; , end else if(ap_ready_int == 1'b1) begin , ap_loop_init <= 1'b0; , end , end , endmodule
T-4	#include <stdio.h> @ @ int <<unk>> <<unk>> int <<unk>> @ { @ int <<unk>> @ int <<unk>> @ int sum = <<unk>> @ ; @ <<unk>> i = <<unk>> i < <<unk>> i++ ) @ { @ sum = sum + <<unk>> @ } @ { @ <<unk>> = sum ; @ ; @ } @ return <<unk>> @ }
H-4	-1.1865907907485962	#include <stdio.h> @ @ int entry_point ( *temptemp1 ) , float ( *temptemp1 ) , float ( *temptemp1 ) , float ( *temptemp1 ) { @ ; @ ; @ ; @ ; @ ; @ ; @ ( *temptemp1 ) = ( *temptemp1 ) = ( *temptemp1 ) = ( *temptemp1 ) ; @ }
D-4	-1.1865907907485962	#include <stdio.h> @ @ int entry_point ( *temptemp1 ) , float ( *temptemp1 ) , float ( *temptemp1 ) , float ( *temptemp1 ) { @ ; @ ; @ ; @ ; @ ; @ ; @ ( *temptemp1 ) = ( *temptemp1 ) = ( *temptemp1 ) = ( *temptemp1 ) ; @ }
P-4	-0.1307 -0.4181 -0.1917 -0.4554 -0.6480 -0.4145 -0.1789 -3.5042 -0.1127 -0.4527 -1.0771 -0.2174 -2.3555 -0.0843 -0.7960 -1.3356 -0.2027 -1.9814 -0.0897 -1.3775 -1.2505 -0.4725 -2.2433 -0.0838 -1.8488 -0.0874 -2.2747 -0.1142 -2.1138 -0.1493 -2.2290 -0.2025 -2.4564 -0.2392 -2.6158 -0.2669 -2.7772 -0.2908 -2.5481 -2.3573 -0.1248 -2.0011 -1.1904 -2.4392 -0.1287 -1.7779 -1.1693 -2.5477 -0.1224 -1.8143 -1.4118 -2.4327 -0.0951 -2.5883 -0.2577 -2.4650 -2.4238
Generate test with beam=5: WER: 61.90
